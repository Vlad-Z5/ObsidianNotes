**Core Themes and Concepts:**

This book serves as a comprehensive guide to Argo CD, a declarative, GitOps continuous delivery tool for Kubernetes. The excerpts highlight several key themes:

- **GitOps as a Guiding Principle:**  
	GitOps is the fundamental concept underpinning Argo CD and the book's content, emphasizing the storage of declarations and configurations in an immutable format within a Git repository.

- **Installation and Management of Argo CD:**  
	The book covers the practical aspects of deploying and interacting with Argo CD. Argo CD supports different installation configurations based on user requirements, scope of management, and high availability concerns. The two primary modes discussed are **Cluster scoped** (default, manages resources across the cluster, preferred for cluster administrators) and **Namespace scoped** (used in multi-tenant environments, allows application teams to manage resources within specific namespaces).
	- **Installation Methods:** Instructions are provided for deploying Argo CD using raw YAML manifests and Helm charts.
	- **Configuration:** Argo CD's configuration is managed through ConfigMaps (argocd-cm, argocd-cmd-params, argocd-rbac-cm, argocd-ssh-known-hosts-cm) and Secrets (identified by the argocd.argoproj.io/secret-type label).
	- **Interaction Methods:** The book details interaction via the User Interface, Command Line Interface (CLI), and other management methods.

- **Managing and Synchronizing Applications:**  
	A significant portion of the book is dedicated to defining, managing, and synchronizing Kubernetes applications using Argo CD.
	- **Application Definition:** Applications are defined using YAML manifests, typically within the same namespace as the Argo CD instance (though support for sourcing from other namespaces exists in later versions).
	- **Application Sources:** Argo CD can source application configurations from various locations, primarily Git repositories. This includes raw YAML files as well as templated configurations generated by tools like Helm and Kustomize.
	- **Tools for Managing YAML Duplication:** The book highlights the problem of YAML duplication when dealing with variations (environments, clusters, etc.) and introduces tools to mitigate this:
		- **Helm:** Described as the "de facto package manager for Kubernetes applications," Helm uses charts (templatized manifests) and values to produce reproducible and parameterized deployments.
		- **Kustomize:** A framework for patching Kubernetes manifests without modifying originals, using a base/overlay structure and kustomization.yaml files. It eliminates YAML duplication by storing differences as deltas. Kustomize can also process Helm charts.
	- **Synchronization Policies and Options:** The book explains how to manage the synchronization process between the Git source of truth and the Kubernetes cluster state. This includes:
		- **Automated Synchronization:** Features like prune: true (remove resources no longer in Git) and selfHeal: true (automatically sync when differences are detected).
		- **Sync Options:** Granular control over synchronization at the application and resource levels.
		- **Managing Resource Differences:** Argo CD allows ignoring differences between the desired state (in Git) and the current state (in Kubernetes) at both the application level and system level.

- **Authentication, Authorization, and Security:**  
	Securing Argo CD and controlling access are covered in detail.
	- **User Management:** Includes the default admin user, local user management, and Single Sign-On (SSO) integration.
	- **Role Based Access Control (RBAC):** Argo CD implements RBAC to define permissions for users and groups. This is configured via the argocd-rbac-cm ConfigMap.
	- **RBAC Policy Structure:** Policies are defined using a format like `p, <role/user/group>, <resource>, <action>, <object>, <effect>`. Application-related permissions have a slightly different structure (`p, <role/user/group>, <resource>, <action>, <appproject>/<object>, <effect>`).
	- **Securing Argo CD:** Discusses configuring TLS certificates for secure communication.
	- **Integrating with Git:** Explains how to configure authentication for accessing Git repositories, including username/password, tokens, and SSH keys (using Deploy Keys in Gitea as an example). SSH keys with passphrases are not currently supported.
	- **Enforcing Signature Verification:** The book touches upon enforcing signature verification for Git commits as a security measure.

- **Cluster Management:**  
	Managing deployments across multiple Kubernetes clusters is a key capability.
	- **Cluster Definition:** Argo CD treats every cluster (local or remote) the same way. Clusters are defined and managed within Argo CD, typically through Secrets with the `argocd.argoproj.io/secret-type: cluster` label.
	- **Adding Clusters:** Clusters can be added using the CLI or declaratively.
	- **Deploying to Multiple Clusters:** Strategies for deploying applications to multiple clusters are discussed, including the App of Apps pattern, using Helm, and leveraging ApplicationSets.
	- **ApplicationSets:** Introduced as a mechanism for automatically generating Argo CD Applications based on various sources (Generators), simplifying the management of a large number of applications or deployments across multiple clusters. Generators include List, Cluster, Git, Matrix, Merge, and SCM Provider generators.

- **Multi-Tenancy:**  
	The book explores how to achieve multi-tenancy within Argo CD, particularly through the use of Argo CD Projects (AppProject).
	- **Argo CD Projects:** Provide a mechanism for organizing and managing applications and resources, enforcing constraints on which repositories, clusters, and namespaces can be used, and defining granular RBAC policies specific to the project.
	- **Resource Management within Projects:** Projects use an "allow/don't allow" model (`spec.sourceRepos`, `spec.destinations`, `spec.namespaceResourceBlacklist`, `spec.namespaceResourceWhitelist`, `spec.clusterResourceWhitelist`, `spec.clusterResourceBlacklist`) to control resource creation and deployment targets.
	- **RBAC within Projects:** Granular RBAC policies can be defined within projects, allowing administrators to delegate permissions to specific users or groups for applications within that project.
	- **Quote:** _"When working through Chapter 6 - Authentication and Authorization, you may have gotten the impression that you can get really granular with RBAC permissions. And you’ll be right! That same level of granularity can be achieved at the Project level. This enables Argo CD administrators to grant permission ranging from “read only” to delegating complete control to specific Argo CD Applications."_

- **Extending Argo CD:**  
	The book demonstrates how Argo CD's functionality can be extended.
	- **Config Management Plugins:** A pluggable framework allowing the integration of additional tools beyond the default Helm, Kustomize, and Jsonnet for generating Kubernetes manifests. Plugins are defined using ConfigManagementPlugin resources.
	- **Plugin Structure:** Plugins have properties like `init` (runs at the beginning of manifest generation), `generate` (produces Kubernetes objects), `discover` (determines plugin applicability), and `parameters` (defines UI display).
	- **Helm and Kustomize Combination:** A practical example of a plugin demonstrates how to use Kustomize to inflate and customize Helm charts, illustrating the power of combining tools.
	- **Plugin Sidecars:** Explains the need for plugin sidecar containers in the repository server Deployment and key configuration requirements for these sidecars.
	- **Environment Variables:** Plugins can access system-defined and user-defined environment variables (prefixed with `ARGOCD_ENV_`).

- **Application Health and Synchronization Wave:**  
	The excerpts touch on how Argo CD determines application health and the order of resource application.
	- **Importance of Probes:** Liveness and readiness probes defined in Kubernetes manifests are crucial for Argo CD to accurately assess the health status of deployed applications, ensuring resources are "Ready" before proceeding.
	- **Manifest Syncwave:** The `argocd.argoproj.io/sync-wave` annotation is used to control the order in which Argo CD applies manifests during synchronization, allowing for dependency management (e.g., applying databases before applications).

- **Key Ideas and Facts:**  
	- Argo CD is a GitOps tool that uses Git as the single source of truth for application deployments.
	- It offers flexible installation options (cluster-scoped and namespace-scoped) to support different organizational structures and multi-tenancy requirements.
	- Configuration is managed through ConfigMaps and Secrets.
	- Argo CD supports managing applications sourced from Git using raw YAML, Helm, and Kustomize.
	- Helm and Kustomize are key tools for reducing YAML duplication and parameterizing deployments.
	- Synchronization can be automated with options like pruning and self-healing.
	- Argo CD provides granular RBAC and security features, including user management, SSO, and TLS configuration.
	- Managing multiple clusters is seamless, treating them uniformly and offering patterns like App of Apps and ApplicationSets.
	- Argo CD Projects are essential for multi-tenancy, providing resource and RBAC isolation.
	- Config Management Plugins allow extending Argo CD's capabilities to incorporate custom tools for manifest generation.
	- Kubernetes probes and sync waves are important for ensuring applications are healthy and deployed in the correct order.

Kind, Helm, Kubectl, Argo cli, jq/yq

K8 Controllers are responsible for drift detection
K8 Operator is built upon controller, main function is to work with CRD based on the state of the cluster

Custom Resources:
- Applications
- AppProjects
- ApplicationSets
K8 Operators:
- Application Controller monitors first CRD
- ApplicationSet Controller monitors third CRD
Repository Server maintains local cache of remote content source, that will be translated into k8 manifests. Responsible for generating resources based on repo type, repo source location, repo path, template.
API Server is a gRPC/REST based server that exposes svc for managing configs (RBAC, cluster and repo memory management, Invocations of App operations like sync, rollback, App management and status reporting, UI, CLI)
Redis
CLI
SSO through Dex
Notifications to Slack, email, etc.


